Ниже — ревью по вашему бандлу class-collector. Я следовал вашему протоколу: сначала прочитал корневые артефакты (manifest.json, symbols.json, slices.jsonl, pointers.jsonl, graph.json, README.md, TOC.md), потом прошёлся по коду в src/….

1) Что видно из корня (артефакты)

Модуль: class-collector.

Файлов в манифесте: 27 (наибольшая доля — пакет internal/index, 14 файлов).

Символов: 117 (schema version: 1).

Граф зависимостей: 36 узлов, 81 ребро.

Крупные исходники по TOC:

cmd/class-collector/main.go — 458 строк.

internal/graph/graph.go — 452 строки.

internal/index/autoanchors.go — 339 строк.

Пакеты: internal/{bundle,cache,diff,graph,index,validate,walkwalk} — границы пакетов кажутся логичными.

Вывод: структура артефактов аккуратная и детерминированная; сортировка и стабильные ID соблюдены, что хорошая база для воспроизводимости.

2) Обзор кода по пакетам

cmd/class-collector

main.go содержит распарсенные флаги, файловый обход, работу с snapshot/delta, сбор артефактов, запись ZIP.

Факт: func main() ≈ 379 строк — это «god‑функция» и главный источник сложности.

internal/index

Сильная сторона: чёткое разделение на anchors/symbols/slices/pointers/manifest, есть symbols_* для Go/TS+JS/Java/C#/Kotlin/Python.

Общие утилиты (joinSym, InferLangByExt) уже вынесены в symbols_common.go.

Конфиг автогенерации якорей (autoanchors.go) держится на глобальной переменной autoCfg (см. SetAutoAnchorsConfig) — это снижает тестируемость и потокобезопасность.

internal/graph

Построение минимального графа импортов для Java/Go/TS/JS; есть tsResolver со своими методами — правильно оформленный «класс» в терминах Go (структура + методы).

internal/bundle

Писатели FULL/DELTA/CHAT zip. Внутри встречаются общие операции «написать JSON/текст в ZIP с фиксированными таймстампами».

internal/cache

Снапшоты и дельты. BuildDelta(prev, curr) ≈ 140 строк — довольно тяжёлая функция.

internal/walkwalk

Дет‑обход, gitignore, фильтры, SHA‑256. Название пакета двусмысленное (см. ниже).

3) Оформление «классов» (структур) и разделение ответственности

Плюсы

Пакетные границы выбраны по доменам: walk → cache → index → graph → bundle. Это помогает понимать «поток данных».

tsResolver в graph.go — пример удачного инкапсулирования поведения вокруг резолвинга импортов.

Типы данных для артефактов (Manifest, ManFile, Symbol, Slice, Pointer) аккуратно описаны тегами JSON и комментариями.

Зоны роста

Композиция через функции вместо «координатора»
Многие подзадачи слабо построены вокруг явного объекта‑координатора. Сейчас «точка сборки» размазана по main.go. Рекомендую ввести «ядро»:

type Pipeline struct {
    Walker    Walker
    Indexer   Indexer
    Grapher   Grapher
    Bundler   Bundler
    Cache     Cache
    // Config, Logger, Context
}

func (p *Pipeline) Run(ctx context.Context, mode Mode, root string) error { ... }


Это уменьшит связность main.go и сделает pipeline тестируемым.

Глобальный конфиг autoCfg
Хорошо бы перевести его в зависимость Indexer’а:

type Indexer struct { AutoCfg AutoAnchorConfig }
// или через опции: NewIndexer(WithAutoAnchors(cfg))


Так вы избавитесь от скрытого состояния и сможете поднимать несколько индексов параллельно.

Магические строки для Kind/Language
Вместо "class"|"interface"|"enum"|"file" и "ts"|"java"|... — введите type Kind string + const (...), и аналогично для языков. Это улучшит статическую проверку и читаемость.

4) Дубликация кода между «классами»

Самая заметная дубликация — regex‑экстракторы символов:

Пары файлов очень похожи по структуре и коду:

symbols_cs.go ↔ symbols_kotlin.go — ~0.67 схожести (по SequenceMatcher).

symbols_kotlin.go ↔ symbols_py.go — ~0.47.

symbols_cs.go ↔ symbols_py.go — ~0.46.

Повторяется общая схема:

локальный lineOf := func(off int) int { ... } — есть во всех symbols_*.go (6 раз);

«собрать primary type», «найти функции», «сложить exports», «сформировать Symbol через joinSym».

Рекомендация: унифицировать через маленький фреймворк «regex‑extractor»

Идея: описать языковой экстрактор декларативно и собрать пайплайн в одном месте.

type Pattern struct {
    Kind   string         // "package" | "type" | "func" ...
    Re     *regexp.Regexp
    // возможно, захваты и политика квалификации (pkg/typ) для joinSym
}

type ExtractSpec struct {
    Lang     string
    Patterns []Pattern
    Qualify  func(pkg, typ, name string) string // например, TS — только тип, Go — recvType
}

type RegexExtractor struct { Spec ExtractSpec }

func (rx RegexExtractor) Extract(relPath string, data []byte) Result { ... }


Для Go всё равно останутся особенности (receiver type), но 80% кода для CS/Kotlin/Python/Java/TS можно собрать из готовых шагов:

одна общая lineOf(off) в symbols_common.go;

общая сортировка и финализация End;

общий конвейер добавления Symbol + exports.

Побочный эффект: добавление нового языка превращается в дописывание декларации, а не копирование файла‑шаблона.

Другая повторяемость

В bundle/zipdelta.go и bundle/zipfull.go повторяются функции записи ZIP‑энтри (например, writeJSONEntry, writeTextEntry, JSONL‑запись). Вынесите это в internal/bundle/ziputil.go с единым fixedZipTime и «санитайзом» путей.

main.go содержит много «склейки»: парсинг флагов, конфиги, выбор режима, вызовы индексации/графа/бандла. Это дублируемая логика между режимами (FULL/DELTA/CHAT): выделите «режимы» в отдельные стратегии, чтобы main только собирал их из флагов.

5) Упрощение и компактизация: где рефакторить в первую очередь
Приоритет A — максимальная отдача

Разбить func main() (~379 строк) на 5–7 логических шагов

parseFlags() (Config, error)

buildWalker(cfg) Walker

loadOrInitCache(cfg)

runPipeline(cfg) (внутри — выбор FULL/DELTA/CHAT стратегии)

emitBundle(cfg, artifacts)
➜ Результат: main() ≤ 80–100 строк, читаемый «сценарий».

Вынести ZIP‑утилиты

Общие writeJSON, writeJSONL, writeText, addFile с фиксированным временем и безопасным путём.

Убрать расхождения вроде writeJSONLEntry vs writeJSONEntry.
➜ Меньше дублирования, меньше рассыпных исправлений при изменении формата.

Убрать глобальный autoCfg

Перевести в зависимость Indexer или передавать конфиг в BuildAutoAnchors явным параметром.
➜ Тестируемость, потокобезопасность.

Приоритет B — «упаковать» индексаторы

Общий каркас для symbols_*.go

Общая утилита lineOf(off) в symbols_common.go.

Переехать на package‑level var reX = regexp.MustCompile(...) везде (часть уже так, часть — нет).

Табличная конфигурация для «первичного типа» и «экспортов».
➜ Минус 25–40% кода в symbols_cs/kotlin/py/java/ts, проще вносить правки.

Типобезопасные константы для Kind/Lang

type Kind string + const (KindClass Kind = "class" ... )
➜ Меньше строковых опечаток, автодополнение IDE, само‑документация.

Приоритет C — читаемость и тесты

BuildDelta(prev, curr) (~140 строк) — декомпозировать

Выделить «поиск переименований по хешу» и «сходство имён» (если есть) в отдельные функции;

Отдельный тип‑контейнер для промежуточных мап.
➜ Локализация изменений и более точные unit‑тесты.

Нейминг и стуттеринг

Пакет internal/walkwalk переименовать в internal/walk или internal/fswalk. Сейчас walkwalk.fswalk.go выглядит тавтологично.

В bundle избавиться от «локальных printf‑обёрток» (например, fmtPrintf), использовать обычный fmt.Sprintf.

Малые утилиты в общее место

Повторяющиеся преобразователи путей/slug/hex/нормализаций — в internal/util или в под‑пакеты indexutil, ziputil, чтобы не размножать версии по файлам.

6) Конкретные находки (метрики и примеры)

Самые длинные функции:

cmd/class-collector/main.go: func main() — ~379 строк.

internal/cache/delta.go: BuildDelta — ~140 строк.

internal/index/symbols_ts.go: extractTS — ~126 строк.

internal/index/autoanchors.go: BuildAutoAnchors — ~106 строк.

Дублирование в экстракторах символов (оценка схожести текста):

symbols_cs.go ↔ symbols_kotlin.go ≈ 0.67.

symbols_kotlin.go ↔ symbols_py.go ≈ 0.47.

symbols_cs.go ↔ symbols_py.go ≈ 0.46.

У всех symbols_*.go встречается локальный lineOf := func(off int) int { … }.

Повтор ZIP‑помощников: zipdelta.go и zipfull.go оба содержат логику записи JSON/JSONL/текста в ZIP — это можно централизовать.

7) Предлагаемый план работ (пошагово)

Итерация 1 (быстрые выигрыши, 1–2 дня)

Разбить main.go на функции и/или ввести Pipeline с режимами FULL/DELTA/CHAT.

Вынести общие ZIP‑helpers в internal/bundle/ziputil.go.

Перевести autoCfg из глобала в зависимость (Indexer/опции конструктора).

Ввести Kind/Lang как типы с константами.

Итерация 2 (снижение дублирования, 2–4 дня)
5. Вынести lineOf() в symbols_common.go; где возможно — компилировать regex на уровне пакета.
6. Ввести каркас RegexExtractor для CS/Kotlin/Python/частично Java/TS.
7. Пройтись по BuildDelta и выделить под‑функции.

Итерация 3 (шлифовка, параллельно с тестами, 2–3 дня)
8. Переименовать walkwalk → walk/fswalk.
9. Пройтись линтером (golangci-lint): funlen, gocognit, dupl, gocyclo.
10. Добавить юнит‑тесты на:
- receiverBaseType (Go),
- extractTS/Java/CS/Kotlin/Py на мини‑фикстурах,
- BuildAutoAnchors (чтобы не регрессило сопоставление якорей),
- BuildDelta (added/changed/removed/renamed сценарии).

8) Резюме

Архитектурные границы пакетов выстроены удачно; формат артефактов стабилен и детерминирован.

Основные проблемы — монолитный main(), повторяемость в language‑экстракторах, локальные дубли ZIP‑утилит и глобальный конфиг автоякорей.

Рекомендованный рефакторинг уменьшит суммарный объём кода в «символьной» части на ~25–40%, упростит добавление языков, улучшит тестируемость и снизит когнитивную нагрузку при ревью и поддержке.

Если нужно, могу подготовить PR‑скелет: Pipeline, ziputil.go, перевод autoCfg, и прототип RegexExtractor на одном из дублирующихся языков (например, Kotlin/C#) — это даст конкретное ощущение масштаба выигрыша.